(* This file is part of DBL, released under MIT license.
 * See LICENSE for details.
*)

import open RedBlackTree

(** Signature *)

pub data Map Key = Map of {
    T
    , empty : {type Val} -> Tree (T Val)
    , method isEmpty : {type Val} -> Tree (T Val) -> [] Bool
    , method insert : {type Val} -> Tree (T Val) -> 
        Key -> Val -> [] Tree (T Val)
    , method insert' : {type Val} -> Tree (T Val) -> 
        Key -> Val -> [] (Pair (Tree (T Val)) Bool)
    , method remove : {type Val} -> Tree (T Val) -> 
        Key -> [] Tree (T Val)
    , method remove' : {type Val} -> Tree (T Val) ->
        Key -> [] (Pair (Tree (T Val)) Bool)
    , method member : {type Val} -> Tree (T Val) -> Key -> [] Bool
    , method find : {type Val} -> Tree (T Val) -> Key -> [] Option Val
    , method operate : {type Val,E} -> Tree (T Val) -> Key ->
        (Unit -> [|E] Option Val) -> (Val -> [|E] Option Val) -> 
        [|E] (Pair (Pair (Option Val) (Option Val)) (Tree (T Val)))
    , method foldl : {type Val, type A,E} -> Tree (T Val) -> 
        (Key -> Val -> A -> [|E] A) -> A -> [|E] A
    , method foldr : {type Val, type A,E} -> Tree (T Val) -> 
        (Key -> Val -> A -> [|E] A) -> A -> [|E] A
    , method toList : {type Val} -> Tree (T Val) -> [] List (Pair Key Val)
    , method toValueList : {type Val} -> Tree (T Val) -> [] List Val
    , method domain : {type Val} -> Tree (T Val) -> [] List Key
    , method map : {type Val, type A,E} -> Tree (T Val) -> 
        (Val -> [|E] A) -> [|E] Tree (T A)
    , method map2 : {type Val, type A,E} -> Tree (T Val) -> 
        (Key -> [|E] A) -> [|E] Tree (T A)
    , method app : {type Val,E} -> Tree (T Val) -> 
        (Key -> Val -> [|E] Unit) -> [|E] Unit
    , method union : {type Val,E} -> Tree (T Val) -> Tree (T Val) ->
        (Key -> Val -> Val -> [|E] Val) -> [|E] Tree (T Val)
    , method partion : {type Val} -> Tree (T Val) -> Key ->
        [] (Pair (Pair (Tree (T Val)) (Option Val)) (Tree (T Val)))
    , method partionLt : {type Val} -> Tree (T Val) -> Key ->
        [] Pair (Tree (T Val)) (Tree (T Val))
    , method partionGt : {type Val} -> Tree (T Val) -> Key ->
        [] Pair (Tree (T Val)) (Tree (T Val))
    , method range : {type Val} -> Tree (T Val) -> Interval Key ->
        Interval Key -> [] Tree (T Val)
    , method least : {type Val} -> Tree (T Val) -> [] Option (T Val)
    , method greatest : {type Val} -> Tree (T Val) -> [] Option (T Val)
    , method leastGt : {type Val} -> Tree (T Val) -> Key -> [] Option (T Val)
    , method leastGeq : {type Val} -> Tree (T Val) -> Key -> [] Option (T Val)
    , method greatestLt : {type Val} -> Tree (T Val) -> 
        Key -> [] Option (T Val)
    , method greatestLeq : {type Val,E} -> Tree (T Val) ->
        Key -> [] Option (T Val) 
}

(** implementation *)

let isEmpty tree =
  match tree with 
  | Leaf => True 
  | _ => False 
  end

let insert compare tree key val =
  match search (fn (key', _ ) => compare key key') tree [] with
  | (Leaf, zipper) => zipRed (key,val) Leaf Leaf zipper
  | ((Node {color, size = bulk, left, right}), zipper) =>
    zip (construct color bulk left (key,val) right) zipper
  end

let insert' compare tree key val =
  match search (fn (key', _ ) => compare key key') tree [] with
  | (Leaf, zipper) => (zipRed (key,val) Leaf Leaf zipper, False)
  | ((Node {color, size = bulk, left, right}), zipper) =>
    (zip (construct color bulk left (key,val) right) zipper, True)
  end

let remove compare tree key =
  match search (fn (key', _ ) => compare key key') tree [] with
  | (Leaf,_) => tree
  | (Node {color, left, right}, zipper) =>
    delete color left right zipper
  end

let remove' compare tree key =
  match search (fn (key', _ ) => compare key key') tree [] with
  | (Leaf,_) => (tree,False)
  | (Node {color, left, right}, zipper) =>
    (delete color left right zipper, True)
  end

let rec member compare tree key =
  match tree with
  | Leaf => False
  | Node {left, value = (key',_), right} => 
    match compare key key' with 
    | Less => member compare left key
    | Equal => True
    | Greater => member compare right key
    end
  end

let rec find compare tree key =
  match tree with 
  | Leaf => None
  | Node {left, value = (key', val),  right} =>
    match compare key key' with
    | Less => find compare left key
    | Equal => Some val
    | Greater => find compare right key
    end
  end 

let rec operate compare tree key absentf presentf =
  match search (fn (key', _ ) => compare key key') tree [] with
  | (Leaf, zipper) => match absentf () with
    | None => (None,None, tree)
    | Some x => (None,Some x, zipRed (key,x) Leaf Leaf zipper)
    end
  | (Node {color, size = bulk, left, value = (_, val), right}, zipper) =>
    match presentf val with 
    | None => (Some val, None, delete color left right zipper)
    | Some x => (Some val, Some x, zip 
      (construct color bulk left (key,x) right) zipper)
    end
  end 

let rec foldr func tree acc = 
  match tree with
  | Leaf => acc
  | Node {left, value = (key, val), right} => 
    let val_right = (foldr func right acc) in
    let val_middle = (func key val val_right) in 
    foldr func left val_middle
  end

let mapFoldr tree func acc = foldr func tree acc

let rec foldl func tree acc =
  match tree with
  | Leaf => acc
  | Node {left, value = (key, val), right} => 
    let val_left = (foldl func left acc) in
    let val_middle = (func key val val_left) in
    foldl func right val_middle
  end 

let mapFoldl tree func acc = foldl func tree acc

let rec map tree func = match tree with
  | Leaf => Leaf
  | Node {color, size = bulk, left, value = (key,value), right} => 
    construct color bulk (map left func) (key,func value) (map right func)
  end

let rec map2 tree func = match tree with
  | Leaf => Leaf
  | Node {color, size = bulk, left, value = (key, _), right} => 
    construct color bulk (map2 left func) (key, func key) (map2 right func)
  end

let rec app tree func = match tree with 
  | Leaf => ()
  | Node {left, value = (key,value), right} => 
    let _ = app left func in
    let _ = func key value in
    app right func
  end

let rec union compare tree1 tree2 merge = 
  match tree1 with
  | Leaf => tree2
  | Node {left = left1, value = (key1,value1), right = right1} =>
    match tree2 with 
    | Leaf => tree1
    | _ => let (output,left2,right2) = 
      split (fn (key2,_) => compare key1 key2) tree2
      in let new_pair = match output with
      | None => (key1,value1)
      | Some (_,value2) => (key1, merge key1 value1 value2)
        end in joinVal (union compare left1 left2 merge) new_pair
        (union compare right1 right2 merge)
    end
  end

let partionLt compare tree key = 
  let (_,left,right) = split (fn (key2,_) => 
    match compare key key2 with
    | Less => Less
    | _ => Greater
    end) tree in (left, right)

let partionGt compare tree key = 
  let (_,left,right) = split (fn (key2,_) =>
  match compare key key2 with
  | Greater => Greater
  | _ => Less
  end) tree in (left, right)

let rec least tree = 
  match tree with 
  | Leaf => None
  | Node {left = Leaf, value} => Some value
  | Node {left} => least left
  end

let rec greatest tree = 
  match tree with 
  | Leaf => None
  | Node { value, right=Leaf} => Some value
  | Node {right} => greatest right
  end

let rec leastGt compare tree key = 
  match tree with
  | Leaf => None
  | Node {left, value = (key1, value), right} =>
    match compare key key1 with
    | Less => match leastGt compare left key with
      | None => Some (key1, value)
      | x => x
      end
    | Equal => least right
    | Greater => leastGt compare right key
    end
  end

let rec leastGeq compare tree key =
  match tree with 
  | Leaf => None
  | Node {left, value = (key1, value), right} =>
    match compare key key1 with
    | Less => match leastGeq compare left key with
      | None => Some (key1,value)
      | x => x
      end
    | Equal => Some (key1, value)
    | Greater => leastGeq compare right key
    end
  end

let rec greatestLt compare tree key = 
  match tree with
  | Leaf => None
  | Node {left, value = (key1,value), right} => 
    match compare key key1 with
    | Less => greatestLt compare left key
    | Equal => greatest left
    | Greater => match greatestLt compare right key with
      | None => Some (key1,value)
      | x => x
      end
    end
  end

let rec greatestLeq compare tree key =
  match tree with 
  | Leaf => None 
  | Node {left, value = (key1,value), right} =>
    match compare key key1 with
    | Less => greatestLt compare left key
    | Equal => Some (key1,value)
    | Greater => match greatestLeq compare right key with
      | None => Some (key1,value)
      | x => x
      end
    end
  end

let toList tree = foldr (fn key value acc => (key, value) :: acc) tree []

let toValueList tree = foldr (fn key value acc => value :: acc) tree []

let domain tree = foldr (fn key value acc => key :: acc) tree []

let partion compare tree key =
  let (output,left,right) = split (fn (key2,_) => compare key key2) tree
  in match output with 
  | None => (left,None,right)
  | Some (_,x) => (left,Some x, right)
  end

let range compare tree left right = 
  match (left,right) with
  | (Inclusion left, Inclusion right) =>
      let (_,middle) = partionGt compare tree left in
      let (result,_) = partionLt compare middle right in result
  | (Inclusion left, Exclusion right) =>
      let (_,middle) = partionGt compare tree left in
      let (result,_) = partionGt compare middle right in result
  | (Exclusion left, Inclusion right) =>
      let (_,middle) = partionLt compare tree left in 
      let (result,_) = partionLt compare middle right in result
  | (Exclusion left, Exclusion right) =>
      let (_,middle) = partionLt compare tree left in
      let (result,_) = partionGt compare middle right in result
  end




pub let make {Key} (compare : Key -> Key -> [] Ordered) = Map {
  T = Pair Key
  , empty = Leaf
  , method isEmpty = isEmpty
  , method insert = insert compare
  , method insert' = insert' compare
  , method remove = remove compare
  , method remove' = remove' compare
  , method member = member compare
  , method find = find compare
  , method operate = operate compare
  , method foldl = mapFoldl
  , method foldr = mapFoldr
  , method toList = toList
  , method toValueList = toValueList 
  , method domain = domain
  , method map = map 
  , method map2 = map2
  , method app = app
  , method union = union compare
  , method partion = partion compare
  , method partionLt = partionLt compare
  , method partionGt = partionGt compare
  , method range = range compare 
  , method least = least
  , method greatest = greatest
  , method leastGt = leastGt compare
  , method leastGeq = leastGeq compare
  , method greatestLt = greatestLt compare
  , method greatestLeq = greatestLeq compare 
}
